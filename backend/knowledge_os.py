# Operating Systems Knowledge Base - 10 Q&A pairs

OS_QA = [
    {
        "question": "What is the difference between process and thread?",
        "answer": "**Process:**\n• Independent execution unit\n• Separate memory space (heap, stack, code)\n• Higher creation overhead\n• Inter-process communication via IPC\n• Crash doesn't affect other processes\n• Context switching is expensive\n\n**Thread:**\n• Lightweight execution unit within process\n• Shared memory space (heap, code)\n• Lower creation overhead\n• Direct memory sharing for communication\n• Crash can affect entire process\n• Context switching is cheaper\n\n**Thread Types:**\n• **User-level:** Managed by application\n• **Kernel-level:** Managed by OS\n• **Hybrid:** Combination of both\n\n**Use threads** for parallelism within application, **processes** for isolation."
    },
    {
        "question": "Explain different CPU scheduling algorithms",
        "answer": "**CPU Scheduling Algorithms:**\n\n**1. First-Come, First-Served (FCFS):**\n• Non-preemptive\n• Simple but can cause convoy effect\n• Average waiting time can be high\n\n**2. Shortest Job First (SJF):**\n• Optimal average waiting time\n• Can be preemptive (SRTF) or non-preemptive\n• Starvation possible for long processes\n\n**3. Round Robin (RR):**\n• Preemptive with time quantum\n• Fair to all processes\n• Performance depends on time quantum size\n\n**4. Priority Scheduling:**\n• Each process has priority\n• Can cause starvation (solved by aging)\n• Can be preemptive or non-preemptive\n\n**5. Multilevel Queue:**\n• Separate queues for different process types\n• Each queue has its own algorithm\n• No movement between queues\n\n**6. Multilevel Feedback Queue:**\n• Processes can move between queues\n• Adaptive based on behavior"
    },
    {
        "question": "How does virtual memory work?",
        "answer": "**Virtual Memory** extends physical RAM using secondary storage:\n\n**Key Concepts:**\n• **Virtual Address Space:** Each process sees continuous memory\n• **Physical Address Space:** Actual RAM locations\n• **Page Table:** Maps virtual to physical addresses\n• **Page Fault:** Access to non-resident page\n\n**Benefits:**\n• Larger address space than physical memory\n• Process isolation and protection\n• Memory sharing between processes\n• Simplified memory management\n\n**Implementation:**\n1. **Paging:** Fixed-size blocks (pages)\n2. **Segmentation:** Variable-size blocks (segments)\n3. **Segmented Paging:** Combination approach\n\n**Page Replacement Algorithms:**\n• **FIFO:** First In, First Out\n• **LRU:** Least Recently Used\n• **Optimal:** Replace page not used for longest time\n• **Clock:** Approximation of LRU"
    },
    {
        "question": "What is deadlock and how can it be prevented?",
        "answer": "**Deadlock** occurs when processes wait for each other indefinitely.\n\n**Four Necessary Conditions:**\n1. **Mutual Exclusion:** Resources can't be shared\n2. **Hold and Wait:** Process holds resources while waiting\n3. **No Preemption:** Resources can't be forcibly taken\n4. **Circular Wait:** Circular chain of waiting processes\n\n**Prevention Strategies:**\n• **Mutual Exclusion:** Make resources shareable (not always possible)\n• **Hold and Wait:** Require all resources at once\n• **No Preemption:** Allow resource preemption\n• **Circular Wait:** Order resources, request in order\n\n**Detection and Recovery:**\n• **Detection:** Use resource allocation graphs\n• **Recovery:** Kill processes, preempt resources\n\n**Avoidance:**\n• **Banker's Algorithm:** Check if allocation leads to safe state\n• **Safe State:** System can allocate resources without deadlock"
    },
    {
        "question": "Explain different types of memory management",
        "answer": "**Memory Management Techniques:**\n\n**1. Contiguous Allocation:**\n• **Fixed Partitioning:** Memory divided into fixed blocks\n• **Variable Partitioning:** Dynamic partition sizes\n• **Problems:** Internal/external fragmentation\n\n**2. Non-Contiguous Allocation:**\n\n**Paging:**\n• Fixed-size blocks (pages/frames)\n• No external fragmentation\n• Page table for address translation\n• Internal fragmentation possible\n\n**Segmentation:**\n• Variable-size logical units\n• Matches program structure\n• External fragmentation possible\n• Segment table for translation\n\n**Segmented Paging:**\n• Combines benefits of both\n• Segments divided into pages\n• Complex but efficient\n\n**3. Virtual Memory:**\n• Demand paging\n• Copy-on-write\n• Memory-mapped files"
    },
    {
        "question": "What are system calls and how do they work?",
        "answer": "**System Calls** provide interface between user programs and OS kernel:\n\n**Purpose:**\n• Access privileged operations\n• Hardware resource management\n• File system operations\n• Process management\n\n**Types of System Calls:**\n\n**1. Process Control:**\n• fork(), exec(), wait(), exit()\n• Create, terminate, wait for processes\n\n**2. File Management:**\n• open(), read(), write(), close()\n• File operations and I/O\n\n**3. Device Management:**\n• ioctl(), read(), write()\n• Hardware device control\n\n**4. Information Maintenance:**\n• getpid(), time(), date()\n• System information retrieval\n\n**5. Communication:**\n• pipe(), shmget(), msgget()\n• Inter-process communication\n\n**Mechanism:**\n1. User program invokes system call\n2. Mode switch from user to kernel\n3. Kernel executes requested operation\n4. Return to user mode with result"
    },
    {
        "question": "How do file systems work?",
        "answer": "**File System** organizes and manages data storage:\n\n**Components:**\n• **Boot Block:** System startup information\n• **Super Block:** File system metadata\n• **Inode Table:** File metadata (Unix/Linux)\n• **Data Blocks:** Actual file content\n\n**File Allocation Methods:**\n\n**1. Contiguous Allocation:**\n• Files stored in consecutive blocks\n• Fast sequential access\n• External fragmentation problem\n\n**2. Linked Allocation:**\n• Blocks linked using pointers\n• No external fragmentation\n• Poor random access performance\n\n**3. Indexed Allocation:**\n• Index block contains pointers to data blocks\n• Good random access\n• Extra overhead for index blocks\n\n**Directory Structure:**\n• **Single-level:** All files in one directory\n• **Two-level:** User directories under root\n• **Tree:** Hierarchical structure\n• **Acyclic Graph:** Shared subdirectories"
    },
    {
        "question": "What is the difference between preemptive and non-preemptive scheduling?",
        "answer": "**Non-Preemptive Scheduling:**\n• Process runs until completion or voluntary yield\n• CPU not forcibly taken away\n• Simple to implement\n• Can lead to poor response time\n• Examples: FCFS, SJF (non-preemptive)\n\n**Preemptive Scheduling:**\n• OS can interrupt running process\n• CPU allocated for time quantum\n• Better response time\n• More complex implementation\n• Context switching overhead\n• Examples: Round Robin, SRTF, Priority (preemptive)\n\n**Advantages of Preemptive:**\n• Better user experience\n• Prevents monopolization\n• Fair resource sharing\n• Real-time system support\n\n**Advantages of Non-Preemptive:**\n• Lower overhead\n• Simpler implementation\n• No context switching during execution"
    },
    {
        "question": "Explain inter-process communication (IPC) mechanisms",
        "answer": "**Inter-Process Communication (IPC) Methods:**\n\n**1. Pipes:**\n• **Anonymous Pipes:** Parent-child communication\n• **Named Pipes (FIFOs):** Unrelated processes\n• Unidirectional data flow\n• Simple but limited\n\n**2. Message Queues:**\n• Structured message passing\n• Asynchronous communication\n• Messages persist until read\n• FIFO or priority-based\n\n**3. Shared Memory:**\n• Fastest IPC mechanism\n• Direct memory access\n• Requires synchronization\n• Large data transfer efficient\n\n**4. Semaphores:**\n• Synchronization primitive\n• Controls access to shared resources\n• Binary or counting semaphores\n• Prevents race conditions\n\n**5. Sockets:**\n• Network communication\n• Local or remote processes\n• TCP (reliable) or UDP (fast)\n• Client-server model\n\n**6. Signals:**\n• Asynchronous notifications\n• Limited data transfer\n• Process control and error handling"
    },
    {
        "question": "What are the different types of operating systems?",
        "answer": "**Operating System Types:**\n\n**1. Batch Operating Systems:**\n• Jobs processed in batches\n• No user interaction during execution\n• High throughput, poor response time\n• Examples: Early mainframe systems\n\n**2. Time-Sharing Systems:**\n• Multiple users share CPU time\n• Interactive computing\n• Round-robin scheduling\n• Examples: Unix, Linux\n\n**3. Real-Time Systems:**\n• **Hard Real-Time:** Strict deadlines\n• **Soft Real-Time:** Flexible deadlines\n• Predictable response times\n• Examples: Embedded systems, robotics\n\n**4. Distributed Systems:**\n• Multiple computers work together\n• Resource sharing across network\n• Fault tolerance and scalability\n• Examples: Cloud computing platforms\n\n**5. Mobile Operating Systems:**\n• Optimized for mobile devices\n• Touch interfaces, power management\n• App-based architecture\n• Examples: Android, iOS\n\n**6. Embedded Systems:**\n• Dedicated functionality\n• Resource constraints\n• Real-time requirements\n• Examples: IoT devices, automotive systems"
    }
]
